# SPDX-License-Identifier: MIT
# Copyright (C) 2021 Canonical Ltd
# Author: Ethan Hsieh <ethan.hsieh@canonical.com>

from pathlib import Path

import binascii
import errno
import json
import logging
import os
import packaging.version
import struct
import sys
import argparse

import aiot

class UbuntuImage:
    def __init__(self, args):
        self.args = args
        self.path = args.path
        self.ubuntu_edition = None
        self.ubuntu_version = None
        self.ubuntu_codename = None
        self.mtk_aiot = None
        self.uboot_env_size = self.args.uboot_env_size
        offset_arg = self.args.uboot_env_redund_offset
        self.uboot_env_redund_offset = 0x100000 if offset_arg == -1 else offset_arg
        self.uboot_env_redund_support = True
        self.eth_oui = "00:0C:E7"
        self.num_of_eth = 0
        self.tools_cfg = []
        self.groups = []
        self.partitions = []
        self.logger = logging.getLogger('aiot')

        self.load_config()
        self.check_min_version()
        self.check_boot_assets()

    def generate_file(self, partition, filename):
        if partition == 'mmc0' and filename == 'MBR_EMMC':
            self.generate_partition_table()
        elif partition == 'mmc0boot1':
            self.generate_uboot_env()

    def check_boot_assets(self):
        if 'mmc0' in self.partitions and self.partitions['mmc0'] == 'MBR_EMMC':
            if not os.path.exists(f"{self.path}/MBR_EMMC_UBUNTU"):
                self.logger.error("No MBR_EMMC_UBUNTU found")
                sys.exit(-errno.ENOENT)

        if not os.path.exists(f"{self.path}/u-boot-initial-env"):
            self.logger.error("No u-boot-initial-env found")
            sys.exit(-errno.ENOENT)

    def load_config(self):
        config_file = f"{self.path}/ubuntu.json"
        with open(config_file, 'r') as fp:
            data = json.load(fp)

            if 'ubuntu-env' in data:
                ubuntu_env = data['ubuntu-env']
                if 'edition' in ubuntu_env:
                    self.ubuntu_edition = ubuntu_env['edition']
                if 'codename' in ubuntu_env:
                    self.ubuntu_codename = ubuntu_env['codename']
                if 'version' in ubuntu_env:
                    self.ubuntu_version = ubuntu_env['version']
                if 'mtk-aiot' in ubuntu_env:
                    self.mtk_aiot = ubuntu_env['mtk-aiot']

            if 'uboot-env' in data:
                uboot_env = data['uboot-env']
                if 'env-size' in uboot_env:
                    self.uboot_env_size = int(uboot_env['env-size'], 0)
                    self.logger.debug(f"ubuntu.json: uboot_env_size={self.uboot_env_size}")
                if 'env-redund-offset' in uboot_env:
                    json_redund_offset = int(uboot_env['env-redund-offset'], 0)
                    if self.uboot_env_redund_offset != json_redund_offset:
                        self.logger.warning(f"ubuntu.json overrides uboot_env_redund_offset=0x{self.uboot_env_redund_offset:08x}")    
                    self.uboot_env_redund_offset = json_redund_offset
                if 'env-redund-support' in uboot_env:
                    self.uboot_env_redund_support = bool(uboot_env['env-redund-support'])
                    self.logger.debug(f"ubuntu.json: uboot_env_redund_support={self.uboot_env_redund_support}")

            if 'ethernet' in data:
                ethernet = data['ethernet']
                if 'oui' in ethernet:
                    self.eth_oui = ethernet['oui']
                if 'num-of-eth' in ethernet:
                    self.num_of_eth = ethernet['num-of-eth']

            self.tools_cfg = data.get('aiot-tools', None)

            if not 'partitions' in data:
                self.logger.error(f"No partition layout found in {config_file}")
                sys.exit(-errno.ENODATA)

            self.partitions = data['partitions']
            for partition in self.partitions:
                if not self.partitions[partition]:
                    if partition == "writable":
                        self.partitions[partition] = "ubuntu-rootfs.img"
                    elif partition == "ubuntu-boot":
                        self.partitions[partition] = "system-boot.img"
                    elif partition == "ubuntu-seed":
                        self.partitions[partition] = "ubuntu-seed.img"
                # The following file is generated by ubuntu.py.
                # The filename is hard-coded.
                if partition == "mmc0boot1":
                    self.partitions[partition] = "u-boot-env.bin"

            if 'groups' in data:
                self.groups = data['groups']

    def check_min_version(self):
        if not self.tools_cfg or not 'min-version' in self.tools_cfg:
            return

        min_version = self.tools_cfg['min-version']

        if packaging.version.parse(min_version) > \
           packaging.version.parse(aiot.version):
            self.logger.error("Your AIoT tools is too old. "
                f"Please upgrade to version {min_version} or higher")
            sys.exit(-errno.ENOENT)

    def generate_partition_table(self):
        # extract MBR
        with open(f"{self.path}/MBR_EMMC", "wb+") as mbr:
            with open(f"{self.path}/MBR_EMMC_UBUNTU", "rb+") as fd:
                for blk_id in range(0, 34):
                    mbr.write(fd.read(512))

            # Remove Backup GPT
            mbr.seek(544)
            mbr.write(b'\x01\x00\x00\x00')
            mbr.seek(528)
            mbr.write(b'\x00\x00\x00\x00')
            mbr.seek(512)
            hdr_crc32 = binascii.crc32(mbr.read(92))
            mbr.seek(528)
            mbr.write(struct.pack("<I", hdr_crc32))

    def generate_uboot_env(self):
        env = aiot.UBootEnv(int(self.uboot_env_size), f"{self.path}/u-boot-initial-env")
        env.gen_mac_addr(self.eth_oui, self.num_of_eth)
        if not self.uboot_env_redund_support:
            self.uboot_env_redund_offset = -1
        env.write_binary(f"{self.path}/u-boot-env.bin", self.uboot_env_redund_offset)

    @classmethod
    def detect(cls, path):
        return os.path.exists(f"{path}/ubuntu.json")

    @classmethod
    def setup_parser(cls, parser):
        pass

    @classmethod
    def define_local_parser(cls, parser):
        cls.parser = argparse.ArgumentParser(parents = [parser], add_help=False)

    @classmethod
    def setup_local_parser(cls):
        cls.setup_parser(cls.parser)
        return cls.parser.parse_args()

    def __str__(self):
        return f"""AIoT Tools: v{aiot.version}
Ubuntu Image:
\tedition:  {self.ubuntu_edition}
\tversion:  {self.ubuntu_version}
\tcodename: {self.ubuntu_codename}
\tmtk_aiot: {self.mtk_aiot}
"""
