# SPDX-License-Identifier: MIT
# Copyright (C) 2024 MediaTek Inc.
# Author: Macpaul Lin <macpaul.lin@mediatek.com>

from pathlib import Path

import binascii
import errno
import json
import logging
import os
import packaging.version
import struct
import sys
import traceback
import argparse

import aiot

class BootFirmwareImage:
    def __init__(self, args):
        self.args = args
        self.path = args.path
        self.description = None
        self.name = None
        self.machine = None
        self.tools_cfg = []
        self.groups = []
        self.partitions = []
        self.uboot_env_size = args.uboot_env_size if args.uboot_env_size else 4096
        self.uboot_env_redund_offset = 0x100000 if args.uboot_env_redund_offset == -1 else args.uboot_env_redund_offset
        self.logger = logging.getLogger('aiot')

        self.load_config()
        self.check_min_version()
        self.check_boot_assets()

    def generate_file(self, partition, filename):
        if partition in ('mmc0boot1', 'nor_env'):
            self.generate_uboot_env()

    def check_boot_assets(self):
        if not os.path.exists(f"{self.path}/u-boot-initial-env"):
            self.logger.error("No u-boot-initial-env found")
            sys.exit(-errno.ENOENT)

    def load_config(self):
        config_file = f"{self.path}/bootfirmware.json"
        with open(config_file, 'r') as fp:
            data = json.load(fp)

            self.name = data.get('name')
            self.description = data.get('description')
            self.machine = data.get('machine')
            self.tools_cfg = data.get('genio-tools', None)

            if not 'partitions' in data:
                self.logger.error(f"No partition layout found in {config_file}")
                sys.exit(-errno.ENODATA)

            self.partitions = data['partitions']
            for partition in self.partitions:
                if not self.partitions[partition]:
                    if partition == "mmc0":
                        self.partitions[partition] = f"{self.name}-{self.machine}.wic.img"

            if 'groups' in data:
                self.groups = data['groups']

    def detect_uboot_env_size(self):
        '''
        IoT Yocto v22.x - v24.0 is default to 4KiB (0x1000) env size.
        However after v24.1, some images may have larger env size
        due to more complicated boot options. Each board may have
        its own env size settings. So we detect the actual env size
        from fw_env.cfg, which is generated by U-Boot recipe during
        build process.
        '''
        legacy_env_size = 0x1000
        try:
            # Looking for configuration line, which looks like this:
            # /dev/mmcblk0boot1        0x0000          0x1000
            # The first integer is offset, which we ignore for now.
            # The last integer is the size.
            # For the moment we take only '/dev/' and '/boot/' as valid.
            with open(f"{self.path}/fw_env.config", 'r') as f:
                for line in f.readlines():
                    line = line.strip()
                    is_dev = line.startswith("/dev/")
                    is_boot = line.startswith("/boot/")
                    if is_dev or is_boot:
                        # set base to '0' to enable auto-detection of hex
                        detected_size = int(line.split()[-1], 0)
                        print("Detected U-Boot env size:", detected_size)
                        return detected_size
        except:
            self.logger.debug(traceback.format_exc())
            self.logger.error(f"Could not detect U-Boot env size, assume {legacy_env_size}")

        return legacy_env_size

    def check_min_version(self):
        if not self.tools_cfg or not 'min-version' in self.tools_cfg:
            return

        min_version = self.tools_cfg['min-version']
        if packaging.version.parse(min_version) > packaging.version.parse(aiot.version):
            self.logger.error("Your Genio tools is too old. "
                f"Please upgrade to version {min_version} or higher")
            sys.exit(-errno.ENOENT)

    def generate_uboot_env(self):
        args_env_size = self.args.uboot_env_size
        if args_env_size:
            env_size = args_env_size
            print(f"Enforce U-Boot env size: {env_size}")
        else:
            env_size = self.detect_uboot_env_size()
        env = aiot.UBootEnv(env_size,
                            f"{self.path}/u-boot-initial-env",
                            self.args)

        env.update_env_list(self.args.uboot_env_set)

        self.logger.debug(f"redund_offset={self.args.uboot_env_redund_offset}")
        env.write_binary(f"{self.path}/u-boot-env.bin", self.args.uboot_env_redund_offset)

    @classmethod
    def detect(cls, path):
        return os.path.exists(f"{path}/bootfirmware.json")

    @classmethod
    def setup_parser(cls, parser):
        pass

    @classmethod
    def define_local_parser(cls, parser):
        cls.parser = argparse.ArgumentParser(parents=[parser], add_help=False)

    @classmethod
    def setup_local_parser(cls):
        cls.setup_parser(cls.parser)
        return cls.parser.parse_args()

    def __str__(self):
        return f"""Genio Tools: v{aiot.version}
Rity Boot Firmware Image:
\tname:  {self.description} ({self.name})
\tmachine:  {self.machine}
"""